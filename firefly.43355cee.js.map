{"mappings":"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","sources":["<anon>","scripts-firefly.js"],"sourcesContent":["// Configuration\nconst CONFIG = {\n    curveIntervalMin: 300,\n    curveIntervalMax: 1700,\n    initialDistanceMultiplier: 1,\n    nodeDistanceMin: 0.01,\n    nodeDistanceMax: 0.1,\n    controlPointMultiplier: 1,\n    controlPointWeightMin: 0.1,\n    controlPointWeightMax: 0.8,\n    controlPointOffsetMin: 0.2,\n    controlPointOffsetMax: 2.0,\n    movementSpeed: 0.2,\n    frameTime: 16.67,\n    fireflySize: 10,\n    numFireflies: 500,\n    redundancyFactor: 2,\n    fftSize: 1024,\n    blinkIntervalMin: 100,\n    blinkIntervalMax: 1000,\n    loudnessScaleMin: 25,\n    loudnessScaleMax: 300,\n    loudnessThreshold: 0.25,\n    lifespanThreshold: 0.75,\n    responseTypeBelow: \"linear\",\n    responseTypeAbove: \"hyperExponential\",\n    debugFlightPath: true\n};\n// Globals\nlet audioContext = null;\nlet audioSource = null;\nlet leftAnalyser = null;\nlet rightAnalyser = null;\nlet animationFrameId = null;\nconst fireflies = [];\nlet leftFrequencyData = [];\nlet rightFrequencyData = [];\n// Canvas Setup\nconst canvas = document.getElementById(\"fireflyCanvas\");\nconst ctx = canvas.getContext(\"2d\");\ncanvas.width = window.innerWidth;\ncanvas.height = window.innerHeight;\n// Helper to clamp positions within screen bounds\nfunction clampPosition(value, min, max) {\n    return Math.max(min, Math.min(max, value));\n}\n// Resets a firefly's properties when lifespan ends\nfunction resetFirefly(firefly, frequencyData) {\n    firefly.fixedLoudness = frequencyData[firefly.frequencyIndex] / 255; // Normalize loudness\n    if (firefly.fixedLoudness < CONFIG.loudnessThreshold) {\n        firefly.lifeSpan = 0; // Deactivate the fly\n        return; // Skip further initialization\n    }\n    const scaledLoudness = responseCurve(firefly.fixedLoudness);\n    firefly.lifeSpan = CONFIG.loudnessScaleMin + scaledLoudness * (CONFIG.loudnessScaleMax - CONFIG.loudnessScaleMin);\n    // Reset to fixed origin for this firefly\n    firefly.pointOriginX = firefly.originX; // Reset pointOrigin to initial origin\n    firefly.pointOriginY = firefly.originY;\n    firefly.x = firefly.originX;\n    firefly.y = firefly.originY;\n    const screenFactor = Math.min(window.innerWidth, window.innerHeight);\n    const defaultDistance = screenFactor * (CONFIG.nodeDistanceMin + Math.random() * (CONFIG.nodeDistanceMax - CONFIG.nodeDistanceMin));\n    const loudnessFactor = 1 + firefly.fixedLoudness;\n    const initialDistance = defaultDistance * loudnessFactor * CONFIG.initialDistanceMultiplier;\n    // Decide upward or downward direction (50-50 chance)\n    const baseAngle = Math.random() < 0.5 ? -90 : 90; // Upward (-90°) or Downward (90°)\n    // Add random deviation of ±10 degrees\n    const deviation = Math.random() * 40 - 20; // Random value between -10 and +10 degrees\n    const angle = (baseAngle + deviation) * (Math.PI / 180); // Convert to radians\n    // Calculate target positions\n    firefly.targetX = clampPosition(firefly.x + initialDistance * Math.cos(angle), 0, window.innerWidth);\n    firefly.targetY = clampPosition(firefly.y + initialDistance * Math.sin(angle), 0, window.innerHeight);\n    const { controlX, controlY } = calculateControlPoints({\n        originX: firefly.pointOriginX,\n        originY: firefly.pointOriginY,\n        targetX: firefly.targetX,\n        targetY: firefly.targetY,\n        distance: initialDistance\n    });\n    firefly.controlX = controlX;\n    firefly.controlY = controlY;\n    firefly.curveTimer = 0;\n    firefly.curveInterval = CONFIG.curveIntervalMin + Math.random() * (CONFIG.curveIntervalMax - CONFIG.curveIntervalMin); // Random interval\n    firefly.glowIntensity = firefly.fixedLoudness;\n}\n// Generates a new target position and control point for a firefly\nfunction generateTargetPosition(firefly) {\n    firefly.pointOriginX = firefly.x; // Update pointOrigin to current position\n    firefly.pointOriginY = firefly.y;\n    const screenFactor = Math.min(window.innerWidth, window.innerHeight);\n    const defaultDistance = screenFactor * (CONFIG.nodeDistanceMin + Math.random() * (CONFIG.nodeDistanceMax - CONFIG.nodeDistanceMin));\n    const loudnessFactor = 1 + firefly.fixedLoudness; // Scale: 1 (0% loudness) to 2 (100% loudness)\n    const distance = defaultDistance * loudnessFactor * CONFIG.initialDistanceMultiplier;\n    const angle = Math.random() * 360;\n    const radians = angle * (Math.PI / 180);\n    firefly.targetX = clampPosition(firefly.pointOriginX + distance * Math.cos(radians), 0, window.innerWidth);\n    firefly.targetY = clampPosition(firefly.pointOriginY + distance * Math.sin(radians), 0, window.innerHeight);\n    const { controlX, controlY } = calculateControlPoints({\n        originX: firefly.pointOriginX,\n        originY: firefly.pointOriginY,\n        targetX: firefly.targetX,\n        targetY: firefly.targetY,\n        distance\n    });\n    firefly.controlX = controlX;\n    firefly.controlY = controlY;\n}\n// Update fireflies' properties based on audio and movement logic\nfunction updateFireflies() {\n    fireflies.forEach((firefly)=>{\n        const frequencyData = firefly.channel === \"left\" ? leftFrequencyData : rightFrequencyData;\n        if (firefly.lifeSpan <= 0 && firefly.blinkTimer >= firefly.blinkInterval) {\n            resetFirefly(firefly, frequencyData); // Reset only after last blink completes\n            firefly.blinkTimer = 0; // Reset timer\n            firefly.blinkInterval = CONFIG.blinkIntervalMin + Math.random() * (CONFIG.blinkIntervalMax - CONFIG.blinkIntervalMin);\n            firefly.blinkProgress = 0;\n        }\n        firefly.curveTimer += CONFIG.frameTime;\n        if (firefly.curveTimer >= firefly.curveInterval) {\n            firefly.curveTimer = 0;\n            generateTargetPosition(firefly); // Generate new target\n            firefly.curveProgress = 0; // Reset curve progress\n        }\n        // Increment movement progress\n        firefly.curveProgress += CONFIG.movementSpeed * CONFIG.frameTime / 1000;\n        moveAlongBezierCurve({\n            firefly,\n            originX: firefly.pointOriginX,\n            originY: firefly.pointOriginY,\n            controlX: firefly.controlX,\n            controlY: firefly.controlY,\n            targetX: firefly.targetX,\n            targetY: firefly.targetY,\n            progress: firefly.curveProgress\n        });\n        if (firefly.blinkTimer < firefly.blinkInterval) {\n            firefly.blinkTimer += CONFIG.frameTime; // Continue blinking\n            const blinkT = firefly.blinkTimer / firefly.blinkInterval;\n            firefly.blinkProgress = blinkT <= 0.5 ? easingFunction(blinkT * 2) : easingFunction(2 - blinkT * 2);\n        } else {\n            firefly.blinkTimer = 0; // Reset timer\n            firefly.blinkInterval = CONFIG.blinkIntervalMin + Math.random() * (CONFIG.blinkIntervalMax - CONFIG.blinkIntervalMin); // Randomize new interval\n        }\n        if (firefly.lifeSpan > 0) firefly.lifeSpan -= 1;\n        else firefly.glowIntensity = 0;\n    });\n}\n// Render fireflies to the canvas\nfunction renderFireflies() {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    fireflies.forEach((firefly, index)=>{\n        if (firefly.lifeSpan > 0) {\n            const fireFlySize = firefly.size * 2; // Adjusted firefly size for glow\n            const blinkOpacity = firefly.blinkProgress * firefly.glowIntensity; // Scaled by blink progress\n            ctx.save();\n            ctx.translate(firefly.x, firefly.y); // Move canvas to firefly position\n            ctx.rotate(firefly.angle); // Rotate canvas to align with movement direction\n            // Draw Glow (circular)\n            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, fireFlySize // Outer circle (edge of the glow)\n            );\n            gradient.addColorStop(0, `rgba(255, 255, 255, ${blinkOpacity})`);\n            gradient.addColorStop(1, \"rgba(255, 255, 255, 0)\");\n            ctx.fillStyle = gradient;\n            ctx.beginPath();\n            ctx.arc(0, 0, fireFlySize, 0, Math.PI * 2);\n            ctx.fill();\n            // Draw Body (smaller oval)\n            const bodyOpacity = Math.min(blinkOpacity + 0.25, 1); // 25% higher opacity\n            ctx.fillStyle = `rgba(255, 255, 255, ${bodyOpacity})`;\n            ctx.beginPath();\n            ctx.ellipse(0, 0, fireFlySize / 6, fireFlySize / 12, 0, 0, Math.PI * 2 // End angle\n            );\n            ctx.fill();\n            ctx.restore(); // Restore canvas state\n            if (CONFIG.debugFlightPath) {\n                // ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';\n                // ctx.beginPath();\n                // ctx.moveTo(firefly.pointOriginX, firefly.pointOriginY); // Start point\n                // ctx.lineTo(firefly.targetX, firefly.targetY); // Target point\n                ctx.stroke();\n                // True Origin (Yellow Dot)\n                ctx.fillStyle = \"rgba(255, 255, 0, 0.5)\"; // Yellow\n                ctx.beginPath();\n                ctx.arc(firefly.originX, firefly.originY, firefly.size / 2, 0, Math.PI * 2);\n                ctx.fill();\n                // Point Origin ()\n                // ctx.fillStyle = 'rgba(0, 255, 255, 0.5)'; //\n                // ctx.beginPath();\n                // ctx.arc(firefly.pointOriginX, firefly.pointOriginY, firefly.size / 2, 0, Math.PI * 2);\n                // ctx.fill();\n                // Current XY (Green Dot)\n                // ctx.fillStyle = 'rgba(0, 255, 0, 0.5)'; // Green\n                // ctx.beginPath();\n                // ctx.arc(firefly.x, firefly.y, firefly.size * 2, 0, Math.PI * 2);\n                // ctx.fill();\n                // Control Points (Blue Dots)\n                // ctx.fillStyle = 'rgba(0, 0, 255, 0.5)';\n                // ctx.beginPath();\n                // ctx.arc(firefly.controlX, firefly.controlY, firefly.size / 4, 0, Math.PI * 2); // Blue dot at control point\n                // ctx.fill();\n                // Ensure flight angle is correctly defined\n                const flightAngle = Math.atan2(firefly.targetY - firefly.y, firefly.targetX - firefly.x); // Initial direction\n                const dx = firefly.controlX - firefly.x; // Control point relative to the fly's current position\n                const dy = firefly.controlY - firefly.y; // Same for y-coordinate\n                // Calculate the angle between the flight direction and the control point\n                const angleToControl = Math.atan2(dy, dx);\n                const relativeAngle = angleToControl - flightAngle;\n                // Normalize the relative angle to [-π, π]\n                const normalizedAngle = Math.atan2(Math.sin(relativeAngle), Math.cos(relativeAngle));\n                // Assign color based on the relative position\n                ctx.fillStyle = normalizedAngle > 0 ? \"rgba(0, 0, 255, 0.5)\" : \"rgba(0, 255, 0, 0.5)\"; // Blue (right), Green (left)\n                ctx.beginPath();\n                ctx.arc(firefly.controlX, firefly.controlY, firefly.size / 4, 0, Math.PI * 2); // Draw the control point\n                ctx.fill();\n                // Destination Points (Red Dots)\n                ctx.fillStyle = \"rgba(255, 0, 0, 1)\"; // Red\n                ctx.beginPath();\n                ctx.arc(firefly.targetX, firefly.targetY, firefly.size / 2, 0, Math.PI * 2);\n                ctx.fill();\n                // Bezier path\n                // ctx.beginPath();\n                // ctx.moveTo(firefly.pointOriginX, firefly.pointOriginY);\n                // ctx.quadraticCurveTo(firefly.controlX, firefly.controlY, firefly.targetX, firefly.targetY);\n                // ctx.strokeStyle = 'blue';\n                // ctx.stroke();\n                // Fly rotation\n                const dotSize = firefly.size / 4; // Small red dot size\n                const tipX = firefly.x + Math.cos(firefly.angle) * firefly.size * 3; // Tip position X\n                const tipY = firefly.y + Math.sin(firefly.angle) * firefly.size * 3; // Tip position Y\n                ctx.fillStyle = \"rgba(255, 255, 255, 0.8)\"; // Red color\n                ctx.beginPath();\n                ctx.arc(tipX, tipY, dotSize, 0, Math.PI * 2); // Red dot at the tip\n                ctx.fill();\n            }\n        }\n    });\n}\n// Main loop for updating and rendering\nfunction updateFrequencyData() {\n    if (leftAnalyser && rightAnalyser) {\n        leftAnalyser.getByteFrequencyData(leftFrequencyData);\n        rightAnalyser.getByteFrequencyData(rightFrequencyData);\n    }\n    updateFireflies();\n    renderFireflies();\n    animationFrameId = requestAnimationFrame(updateFrequencyData);\n}\nfunction easingFunction(t) {\n    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n}\nfunction calculateControlPoints({ originX = 0, originY = 0, targetX = 0, targetY = 0, distance = 1, weightMin = CONFIG.controlPointWeightMin, weightMax = CONFIG.controlPointWeightMax, offsetMin = CONFIG.controlPointOffsetMin, offsetMax = CONFIG.controlPointOffsetMax }) {\n    const weight = weightMin + Math.random() * (weightMax - weightMin);\n    const baseX = originX + weight * (targetX - originX);\n    const baseY = originY + weight * (targetY - originY);\n    const offsetFactor = offsetMin + Math.random() * (offsetMax - offsetMin);\n    const offsetDistance = distance * offsetFactor;\n    // Check for degenerate case (origin == target)\n    const deltaX = targetX - originX;\n    const deltaY = targetY - originY;\n    // Randomly flip between clockwise and counterclockwise\n    const flipDirection = Math.random() < 0.5 ? 1 : -1;\n    // Calculate perpendicular angle with random flipping\n    const angle = deltaX === 0 && deltaY === 0 ? Math.random() * Math.PI * 2 : Math.atan2(deltaY, deltaX) + flipDirection * Math.PI / 2;\n    return {\n        controlX: baseX + Math.cos(angle) * offsetDistance,\n        controlY: baseY + Math.sin(angle) * offsetDistance\n    };\n}\nfunction moveAlongBezierCurve({ firefly, originX, originY, controlX, controlY, targetX, targetY, progress }) {\n    const bezier = (p0, p1, p2, t)=>Math.pow(1 - t, 2) * p0 + 2 * (1 - t) * t * p1 + Math.pow(t, 2) * p2;\n    const bezierTangent = (p0, p1, p2, t)=>{\n        const dx = 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1); // Derivative for x\n        const dy = 2 * (1 - t) * (p2 - p1) + 2 * t * (p2 - p0); // Derivative for y\n        return {\n            dx,\n            dy\n        };\n    };\n    firefly.x = bezier(originX, controlX, targetX, progress);\n    firefly.y = bezier(originY, controlY, targetY, progress);\n    const { dx, dy } = bezierTangent(originX, controlX, targetX, progress);\n    firefly.angle = Math.atan2(dy, dx);\n}\nfunction calculateScaledLifespan(loudness) {\n    const t = Math.min(Math.max(loudness, 0), 1);\n    if (t < CONFIG.lifespanThreshold) {\n        // Scale loudness below threshold linearly to midLifespanSeconds\n        const scaled = t / CONFIG.lifespanThreshold;\n        return (CONFIG.minLifespanSeconds + scaled * (CONFIG.midLifespanSeconds - CONFIG.minLifespanSeconds)) * 1000 / CONFIG.frameTime; // Convert seconds to frames\n    } else {\n        // Scale loudness above threshold to maxLifespanSeconds\n        const scaled = (t - CONFIG.lifespanThreshold) / (1 - CONFIG.lifespanThreshold);\n        return (CONFIG.midLifespanSeconds + scaled * (CONFIG.maxLifespanSeconds - CONFIG.midLifespanSeconds)) * 1000 / CONFIG.frameTime; // Convert seconds to frames\n    }\n}\nfunction responseCurve(loudness) {\n    const midpoint = CONFIG.lifespanThreshold;\n    const belowType = CONFIG.responseTypeBelow; // Configurable response type below midpoint\n    const aboveType = CONFIG.responseTypeAbove; // Configurable response type above midpoint\n    const computeBelow = (loudness)=>{\n        switch(belowType){\n            case \"linear\":\n                return loudness / midpoint; // Linear scaling\n            case \"logarithmic\":\n                return Math.log(1 + loudness / midpoint) / Math.log(2); // Log base 2 scaling\n            case \"quadratic\":\n                return Math.pow(loudness / midpoint, 2); // Quadratic scaling\n            case \"cubic\":\n                return Math.pow(loudness / midpoint, 3); // Cubic scaling\n            case \"exponential\":\n                return Math.exp(loudness / midpoint) - 1; // Exponential growth\n            case \"hyperExponential\":\n                return (Math.exp(loudness / midpoint) - 1) * 2; // Doubled exponential effect\n            default:\n                return loudness; // Default to linear\n        }\n    };\n    const computeAbove = (relativeLoudness, baseValue)=>{\n        switch(aboveType){\n            case \"linear\":\n                return baseValue + relativeLoudness; // Linear scaling\n            case \"logarithmic\":\n                return baseValue + Math.log(1 + relativeLoudness) / Math.log(2); // Log base 2 scaling\n            case \"quadratic\":\n                return baseValue + Math.pow(relativeLoudness, 2); // Quadratic scaling\n            case \"cubic\":\n                return baseValue + Math.pow(relativeLoudness, 3) * 3; // Cubic scaling\n            case \"exponential\":\n                return baseValue + (Math.exp(relativeLoudness) - 1); // Exponential scaling\n            case \"hyperExponential\":\n                return baseValue + (Math.exp(relativeLoudness) - 1) * 2; // Doubled exponential effect\n            default:\n                return loudness; // Default to linear\n        }\n    };\n    if (loudness < midpoint) return computeBelow(loudness); // Below midpoint logic\n    else {\n        const baseValue = computeBelow(midpoint); // Smooth transition value\n        const relativeLoudness = (loudness - midpoint) / (1 - midpoint);\n        return computeAbove(relativeLoudness, baseValue); // Above midpoint logic\n    }\n}\n// Audio setup and initialization\ndocument.getElementById(\"audioUpload\").addEventListener(\"change\", async (event)=>{\n    const file = event.target.files[0];\n    if (file) {\n        audioContext = new (window.AudioContext || window.webkitAudioContext)();\n        const arrayBuffer = await file.arrayBuffer();\n        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n        // Create source and analyzers\n        audioSource = audioContext.createBufferSource();\n        audioSource.buffer = audioBuffer;\n        const splitter = audioContext.createChannelSplitter(2);\n        leftAnalyser = audioContext.createAnalyser();\n        rightAnalyser = audioContext.createAnalyser();\n        leftAnalyser.fftSize = 1024;\n        rightAnalyser.fftSize = 1024;\n        audioSource.connect(splitter);\n        splitter.connect(leftAnalyser, 0);\n        splitter.connect(rightAnalyser, 1);\n        audioSource.connect(audioContext.destination);\n        leftAnalyser.fftSize = CONFIG.fftSize;\n        rightAnalyser.fftSize = CONFIG.fftSize;\n        leftFrequencyData = new Uint8Array(leftAnalyser.frequencyBinCount);\n        rightFrequencyData = new Uint8Array(rightAnalyser.frequencyBinCount);\n        for(let i = 0; i < CONFIG.numFireflies; i++){\n            const frequencyIndex = i % (leftAnalyser.frequencyBinCount / CONFIG.redundancyFactor);\n            // Equal split for left and right channels\n            const isLeftChannel = i % 2 === 0; // Determine channel\n            const frequencySpread = frequencyIndex / (leftAnalyser.frequencyBinCount / CONFIG.redundancyFactor);\n            const originX = isLeftChannel ? window.innerWidth * (0.5 - frequencySpread * 0.5 // Left: Center to Left\n            ) : window.innerWidth * (0.5 + frequencySpread * 0.5); // Right: Center to Right\n            const originY = window.innerHeight / 2; // Middle of the screen\n            fireflies.push({\n                frequencyIndex,\n                channel: i % 2 === 0 ? \"left\" : \"right\",\n                originX,\n                originY,\n                x: originX,\n                y: originY,\n                size: CONFIG.fireflySize,\n                glowIntensity: 0,\n                lifeSpan: 0,\n                fixedLoudness: 0,\n                curveTimer: 0,\n                curveInterval: 0,\n                targetX: 0,\n                targetY: 0,\n                controlX: 0,\n                controlY: 0,\n                curveProgress: 0\n            });\n        }\n        console.log(\"Audio loaded and fireflies initialized.\");\n        audioSource.start();\n        audioSource.onended = ()=>cancelAnimationFrame(animationFrameId);\n        updateFrequencyData();\n    }\n});\n\n//# sourceMappingURL=firefly.43355cee.js.map\n","// Configuration\r\nconst CONFIG = {\r\n    curveIntervalMin: 300, // Minimum curve interval in ms\r\n    curveIntervalMax: 1700, // Maximum curve interval in ms\r\n    initialDistanceMultiplier: 1, // Multiplier for initial distance based on loudness\r\n    nodeDistanceMin: 0.01, // Minimum distance between nodes in fly size units\r\n    nodeDistanceMax: 0.1, // Maximum distance between nodes in fly size units\r\n    controlPointMultiplier: 1, // Multiplier for random control point offset\r\n    controlPointWeightMin: 0.1, // Minimum weight (10%)\r\n    controlPointWeightMax: 0.8, // Maximum weight (80%)\r\n    controlPointOffsetMin: 0.2, // Minimum offset factor (20%)\r\n    controlPointOffsetMax: 2.0, // Maximum offset factor (200%)\r\n    movementSpeed: 0.2, // Speed of movement along Bezier curve\r\n    frameTime: 16.67, // Approximate time per frame at 60 FPS\r\n    fireflySize: 10, // Default size of each firefly\r\n    numFireflies: 500, // Total number of fireflies\r\n    redundancyFactor: 2, // Two fireflies per frequency for redundancy\r\n    fftSize: 1024, // Default FFT size\r\n\tblinkIntervalMin: 100, // Minimum blink interval in ms (0.1s)\r\n\tblinkIntervalMax: 1000, // Maximum blink interval in ms (1s)\r\n\tloudnessScaleMin: 25, // Minimum lifespan scaling from loudness\r\n\tloudnessScaleMax: 300, // Maximum lifespan scaling from loudness\r\n\tloudnessThreshold: 0.25, // Minimum loudness (5%) to activate flies\r\n    lifespanThreshold: 0.75, // Midpoint for the response curve (default: 75% loudness)\r\n    responseTypeBelow: \"linear\", // Type of scaling below midpoint (e.g., \"quadratic\", \"linear\")\r\n    responseTypeAbove: \"hyperExponential\",     // Type of scaling above midpoint (e.g., \"cubic\", \"exponential\")\r\n    debugFlightPath: true,\r\n};\r\n\r\n// Globals\r\nlet audioContext = null;\r\nlet audioSource = null;\r\nlet leftAnalyser = null;\r\nlet rightAnalyser = null;\r\nlet animationFrameId = null;\r\n\r\nconst fireflies = [];\r\nlet leftFrequencyData = [];\r\nlet rightFrequencyData = [];\r\n\r\n// Canvas Setup\r\nconst canvas = document.getElementById('fireflyCanvas');\r\nconst ctx = canvas.getContext('2d');\r\ncanvas.width = window.innerWidth;\r\ncanvas.height = window.innerHeight;\r\n\r\n// Helper to clamp positions within screen bounds\r\nfunction clampPosition(value, min, max) {\r\n    return Math.max(min, Math.min(max, value));\r\n}\r\n\r\n// Resets a firefly's properties when lifespan ends\r\nfunction resetFirefly(firefly, frequencyData) {\r\n    firefly.fixedLoudness = frequencyData[firefly.frequencyIndex] / 255; // Normalize loudness\r\n\r\n    if (firefly.fixedLoudness < CONFIG.loudnessThreshold) {\r\n        firefly.lifeSpan = 0; // Deactivate the fly\r\n        return; // Skip further initialization\r\n    }\r\n\r\n    const scaledLoudness = responseCurve(firefly.fixedLoudness);\r\n    firefly.lifeSpan = CONFIG.loudnessScaleMin +\r\n        scaledLoudness * (CONFIG.loudnessScaleMax - CONFIG.loudnessScaleMin);\r\n\r\n    // Reset to fixed origin for this firefly\r\n    firefly.pointOriginX = firefly.originX; // Reset pointOrigin to initial origin\r\n    firefly.pointOriginY = firefly.originY;\r\n\r\n    firefly.x = firefly.originX;\r\n    firefly.y = firefly.originY;\r\n\r\n    const screenFactor = Math.min(window.innerWidth, window.innerHeight);\r\n    const defaultDistance =\r\n        screenFactor *\r\n        (CONFIG.nodeDistanceMin +\r\n            Math.random() * (CONFIG.nodeDistanceMax - CONFIG.nodeDistanceMin));\r\n    const loudnessFactor = 1 + firefly.fixedLoudness;\r\n    const initialDistance =\r\n        defaultDistance * loudnessFactor * CONFIG.initialDistanceMultiplier;\r\n\r\n    // Decide upward or downward direction (50-50 chance)\r\n    const baseAngle = Math.random() < 0.5 ? -90 : 90; // Upward (-90°) or Downward (90°)\r\n\r\n    // Add random deviation of ±10 degrees\r\n    const deviation = Math.random() * 40 - 20; // Random value between -10 and +10 degrees\r\n    const angle = (baseAngle + deviation) * (Math.PI / 180); // Convert to radians\r\n\r\n    // Calculate target positions\r\n    firefly.targetX = clampPosition(\r\n        firefly.x + initialDistance * Math.cos(angle),\r\n        0,\r\n        window.innerWidth\r\n    );\r\n    firefly.targetY = clampPosition(\r\n        firefly.y + initialDistance * Math.sin(angle),\r\n        0,\r\n        window.innerHeight\r\n    );\r\n\r\n    const { controlX, controlY } = calculateControlPoints({\r\n        originX: firefly.pointOriginX, // Use pointOrigin for the curve\r\n        originY: firefly.pointOriginY,\r\n        targetX: firefly.targetX,\r\n        targetY: firefly.targetY,\r\n        distance: initialDistance,\r\n    });\r\n\r\n    firefly.controlX = controlX;\r\n    firefly.controlY = controlY;\r\n\r\n    firefly.curveTimer = 0;\r\n    firefly.curveInterval =\r\n        CONFIG.curveIntervalMin +\r\n        Math.random() * (CONFIG.curveIntervalMax - CONFIG.curveIntervalMin); // Random interval\r\n    firefly.glowIntensity = firefly.fixedLoudness;\r\n}\r\n\r\n// Generates a new target position and control point for a firefly\r\nfunction generateTargetPosition(firefly) {\r\n    firefly.pointOriginX = firefly.x; // Update pointOrigin to current position\r\n    firefly.pointOriginY = firefly.y;\r\n\r\n    const screenFactor = Math.min(window.innerWidth, window.innerHeight);\r\n    const defaultDistance =\r\n        screenFactor *\r\n        (CONFIG.nodeDistanceMin +\r\n            Math.random() * (CONFIG.nodeDistanceMax - CONFIG.nodeDistanceMin));\r\n    const loudnessFactor = 1 + firefly.fixedLoudness; // Scale: 1 (0% loudness) to 2 (100% loudness)\r\n    const distance = defaultDistance * loudnessFactor * CONFIG.initialDistanceMultiplier;\r\n\r\n    const angle = Math.random() * 360;\r\n    const radians = angle * (Math.PI / 180);\r\n\r\n    firefly.targetX = clampPosition(\r\n        firefly.pointOriginX + distance * Math.cos(radians),\r\n        0,\r\n        window.innerWidth\r\n    );\r\n    firefly.targetY = clampPosition(\r\n        firefly.pointOriginY + distance * Math.sin(radians),\r\n        0,\r\n        window.innerHeight\r\n    );\r\n\r\n    const { controlX, controlY } = calculateControlPoints({\r\n        originX: firefly.pointOriginX,\r\n        originY: firefly.pointOriginY,\r\n        targetX: firefly.targetX,\r\n        targetY: firefly.targetY,\r\n        distance,\r\n    });\r\n\r\n    firefly.controlX = controlX;\r\n    firefly.controlY = controlY;\r\n}\r\n\r\n\r\n// Update fireflies' properties based on audio and movement logic\r\nfunction updateFireflies() {\r\n    fireflies.forEach(firefly => {\r\n        const frequencyData = firefly.channel === 'left' ? leftFrequencyData : rightFrequencyData;\r\n\r\n\t\tif (firefly.lifeSpan <= 0 && firefly.blinkTimer >= firefly.blinkInterval) {\r\n\t\t\tresetFirefly(firefly, frequencyData); // Reset only after last blink completes\r\n\t\t\tfirefly.blinkTimer = 0; // Reset timer\r\n\t\t\tfirefly.blinkInterval =\r\n\t\t\t\tCONFIG.blinkIntervalMin +\r\n\t\t\t\tMath.random() * (CONFIG.blinkIntervalMax - CONFIG.blinkIntervalMin);\r\n\t\t\tfirefly.blinkProgress = 0;\r\n\t\t}\r\n\r\n        firefly.curveTimer += CONFIG.frameTime;\r\n\r\n\t\tif (firefly.curveTimer >= firefly.curveInterval) {\r\n\t\t\tfirefly.curveTimer = 0;\r\n\t\t\tgenerateTargetPosition(firefly); // Generate new target\r\n\t\t\tfirefly.curveProgress = 0; // Reset curve progress\r\n\t\t}\r\n\r\n\t\t// Increment movement progress\r\n\t\tfirefly.curveProgress += CONFIG.movementSpeed * CONFIG.frameTime / 1000;\r\n\r\n\t\tmoveAlongBezierCurve({\r\n\t\t\tfirefly,\r\n\t\t\toriginX: firefly.pointOriginX, // Use pointOrigin for movement\r\n\t\t\toriginY: firefly.pointOriginY,\r\n\t\t\tcontrolX: firefly.controlX,\r\n\t\t\tcontrolY: firefly.controlY,\r\n\t\t\ttargetX: firefly.targetX,\r\n\t\t\ttargetY: firefly.targetY,\r\n\t\t\tprogress: firefly.curveProgress,\r\n\t\t});\r\n\r\n\t\tif (firefly.blinkTimer < firefly.blinkInterval) {\r\n\t\t\tfirefly.blinkTimer += CONFIG.frameTime; // Continue blinking\r\n\t\t\tconst blinkT = firefly.blinkTimer / firefly.blinkInterval;\r\n\t\t\tfirefly.blinkProgress =\r\n\t\t\t\tblinkT <= 0.5\r\n\t\t\t\t\t? easingFunction(blinkT * 2)\r\n\t\t\t\t\t: easingFunction(2 - blinkT * 2);\r\n\t\t} else {\r\n\t\t\tfirefly.blinkTimer = 0; // Reset timer\r\n\t\t\tfirefly.blinkInterval =\r\n\t\t\t\tCONFIG.blinkIntervalMin +\r\n\t\t\t\tMath.random() * (CONFIG.blinkIntervalMax - CONFIG.blinkIntervalMin); // Randomize new interval\r\n\t\t}\r\n\r\n        if (firefly.lifeSpan > 0) {\r\n            firefly.lifeSpan -= 1;\r\n        } else {\r\n            firefly.glowIntensity = 0;\r\n        }\r\n    });\r\n}\r\n\r\n\r\n// Render fireflies to the canvas\r\nfunction renderFireflies() {\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n    fireflies.forEach((firefly, index) => {\r\n        if (firefly.lifeSpan > 0) { // Only render active fireflies\r\n            const fireFlySize = firefly.size * 2; // Adjusted firefly size for glow\r\n            const blinkOpacity = firefly.blinkProgress * firefly.glowIntensity; // Scaled by blink progress\r\n\r\n            ctx.save();\r\n            ctx.translate(firefly.x, firefly.y); // Move canvas to firefly position\r\n            ctx.rotate(firefly.angle); // Rotate canvas to align with movement direction\r\n\r\n            // Draw Glow (circular)\r\n            const gradient = ctx.createRadialGradient(\r\n                0, 0, 0, // Inner circle (center)\r\n                0, 0, fireFlySize // Outer circle (edge of the glow)\r\n            );\r\n            gradient.addColorStop(0, `rgba(255, 255, 255, ${blinkOpacity})`);\r\n            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');\r\n            ctx.fillStyle = gradient;\r\n            ctx.beginPath();\r\n            ctx.arc(0, 0, fireFlySize, 0, Math.PI * 2);\r\n            ctx.fill();\r\n\r\n            // Draw Body (smaller oval)\r\n            const bodyOpacity = Math.min(blinkOpacity + 0.25, 1); // 25% higher opacity\r\n            ctx.fillStyle = `rgba(255, 255, 255, ${bodyOpacity})`;\r\n            ctx.beginPath();\r\n            ctx.ellipse(\r\n                0, // Center x (already translated)\r\n                0, // Center y (already translated)\r\n                fireFlySize / 6, // Horizontal radius\r\n                fireFlySize / 12, // Vertical radius\r\n                0, // Rotation\r\n                0, // Start angle\r\n                Math.PI * 2 // End angle\r\n            );\r\n            ctx.fill();\r\n\r\n            ctx.restore(); // Restore canvas state\r\n\t\t\t\r\n\t\t\tif (CONFIG.debugFlightPath) {\r\n\t\t\t\t// ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';\r\n\t\t\t\t// ctx.beginPath();\r\n\t\t\t\t// ctx.moveTo(firefly.pointOriginX, firefly.pointOriginY); // Start point\r\n\t\t\t\t// ctx.lineTo(firefly.targetX, firefly.targetY); // Target point\r\n\t\t\t\tctx.stroke();\r\n                \r\n\t\t\t\t// True Origin (Yellow Dot)\r\n\t\t\t\tctx.fillStyle = 'rgba(255, 255, 0, 0.5)'; // Yellow\r\n\t\t\t\tctx.beginPath();\r\n\t\t\t\tctx.arc(firefly.originX, firefly.originY, firefly.size / 2, 0, Math.PI * 2);\r\n\t\t\t\tctx.fill();\r\n\t\t\t\t\r\n\t\t\t\t// Point Origin ()\r\n\t\t\t\t// ctx.fillStyle = 'rgba(0, 255, 255, 0.5)'; //\r\n\t\t\t\t// ctx.beginPath();\r\n\t\t\t\t// ctx.arc(firefly.pointOriginX, firefly.pointOriginY, firefly.size / 2, 0, Math.PI * 2);\r\n\t\t\t\t// ctx.fill();\r\n\t\t\t\t\r\n\t\t\t\t// Current XY (Green Dot)\r\n\t\t\t\t// ctx.fillStyle = 'rgba(0, 255, 0, 0.5)'; // Green\r\n\t\t\t\t// ctx.beginPath();\r\n\t\t\t\t// ctx.arc(firefly.x, firefly.y, firefly.size * 2, 0, Math.PI * 2);\r\n\t\t\t\t// ctx.fill();\r\n\t\t\t\t\r\n\t\t\t\t// Control Points (Blue Dots)\r\n                // ctx.fillStyle = 'rgba(0, 0, 255, 0.5)';\r\n                // ctx.beginPath();\r\n                // ctx.arc(firefly.controlX, firefly.controlY, firefly.size / 4, 0, Math.PI * 2); // Blue dot at control point\r\n                // ctx.fill();\r\n\r\n                // Ensure flight angle is correctly defined\r\n                const flightAngle = Math.atan2(firefly.targetY - firefly.y, firefly.targetX - firefly.x); // Initial direction\r\n                const dx = firefly.controlX - firefly.x; // Control point relative to the fly's current position\r\n                const dy = firefly.controlY - firefly.y; // Same for y-coordinate\r\n\r\n                // Calculate the angle between the flight direction and the control point\r\n                const angleToControl = Math.atan2(dy, dx);\r\n                const relativeAngle = angleToControl - flightAngle;\r\n\r\n                // Normalize the relative angle to [-π, π]\r\n                const normalizedAngle = Math.atan2(Math.sin(relativeAngle), Math.cos(relativeAngle));\r\n\r\n                // Assign color based on the relative position\r\n                ctx.fillStyle = normalizedAngle > 0 ? 'rgba(0, 0, 255, 0.5)' : 'rgba(0, 255, 0, 0.5)'; // Blue (right), Green (left)\r\n                ctx.beginPath();\r\n                ctx.arc(firefly.controlX, firefly.controlY, firefly.size / 4, 0, Math.PI * 2); // Draw the control point\r\n                ctx.fill();\r\n\t\t\t\t\r\n\t\t\t\t// Destination Points (Red Dots)\r\n\t\t\t\tctx.fillStyle = 'rgba(255, 0, 0, 1)'; // Red\r\n\t\t\t\tctx.beginPath();\r\n\t\t\t\tctx.arc(firefly.targetX, firefly.targetY, firefly.size / 2, 0, Math.PI * 2);\r\n\t\t\t\tctx.fill();\r\n\r\n                // Bezier path\r\n                // ctx.beginPath();\r\n                // ctx.moveTo(firefly.pointOriginX, firefly.pointOriginY);\r\n                // ctx.quadraticCurveTo(firefly.controlX, firefly.controlY, firefly.targetX, firefly.targetY);\r\n                // ctx.strokeStyle = 'blue';\r\n                // ctx.stroke();\r\n\t\t\t\t\r\n\t\t\t\t// Fly rotation\r\n\t\t\t\tconst dotSize = firefly.size / 4; // Small red dot size\r\n\t\t\t\tconst tipX = firefly.x + Math.cos(firefly.angle) * firefly.size * 3; // Tip position X\r\n\t\t\t\tconst tipY = firefly.y + Math.sin(firefly.angle) * firefly.size * 3; // Tip position Y\r\n\r\n\t\t\t\tctx.fillStyle = 'rgba(255, 255, 255, 0.8)'; // Red color\r\n\t\t\t\tctx.beginPath();\r\n\t\t\t\tctx.arc(tipX, tipY, dotSize, 0, Math.PI * 2); // Red dot at the tip\r\n\t\t\t\tctx.fill();\r\n\t\t\t}\r\n\t\t\t\r\n        }\r\n    });\r\n}\r\n\r\n// Main loop for updating and rendering\r\nfunction updateFrequencyData() {\r\n    if (leftAnalyser && rightAnalyser) {\r\n        leftAnalyser.getByteFrequencyData(leftFrequencyData);\r\n        rightAnalyser.getByteFrequencyData(rightFrequencyData);\r\n    }\r\n\r\n    updateFireflies();\r\n    renderFireflies();\r\n\r\n    animationFrameId = requestAnimationFrame(updateFrequencyData);\r\n}\r\n\r\nfunction easingFunction(t) {\r\n    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\r\n}\r\n\r\nfunction calculateControlPoints({\r\n    originX = 0,\r\n    originY = 0,\r\n    targetX = 0,\r\n    targetY = 0,\r\n    distance = 1,\r\n    weightMin = CONFIG.controlPointWeightMin,\r\n    weightMax = CONFIG.controlPointWeightMax,\r\n    offsetMin = CONFIG.controlPointOffsetMin,\r\n    offsetMax = CONFIG.controlPointOffsetMax,\r\n}) {\r\n    const weight = weightMin + Math.random() * (weightMax - weightMin);\r\n    const baseX = originX + weight * (targetX - originX);\r\n    const baseY = originY + weight * (targetY - originY);\r\n\r\n    const offsetFactor = offsetMin + Math.random() * (offsetMax - offsetMin);\r\n    const offsetDistance = distance * offsetFactor;\r\n\r\n    // Check for degenerate case (origin == target)\r\n    const deltaX = targetX - originX;\r\n    const deltaY = targetY - originY;\r\n    // Randomly flip between clockwise and counterclockwise\r\n    const flipDirection = Math.random() < 0.5 ? 1 : -1;\r\n\r\n    // Calculate perpendicular angle with random flipping\r\n    const angle = deltaX === 0 && deltaY === 0 \r\n        ? Math.random() * Math.PI * 2 \r\n        : Math.atan2(deltaY, deltaX) + flipDirection * Math.PI / 2;\r\n\r\n    return {\r\n        controlX: baseX + Math.cos(angle) * offsetDistance,\r\n        controlY: baseY + Math.sin(angle) * offsetDistance,\r\n    };\r\n}\r\n\r\nfunction moveAlongBezierCurve({ firefly, originX, originY, controlX, controlY, targetX, targetY, progress }) {\r\n    const bezier = (p0, p1, p2, t) => Math.pow(1 - t, 2) * p0 + 2 * (1 - t) * t * p1 + Math.pow(t, 2) * p2;\r\n\tconst bezierTangent = (p0, p1, p2, t) => {\r\n\t\tconst dx = 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1); // Derivative for x\r\n\t\tconst dy = 2 * (1 - t) * (p2 - p1) + 2 * t * (p2 - p0); // Derivative for y\r\n\t\treturn { dx, dy };\r\n\t};\r\n\r\n    firefly.x = bezier(originX, controlX, targetX, progress);\r\n    firefly.y = bezier(originY, controlY, targetY, progress);\r\n\r\n    const { dx, dy } = bezierTangent(originX, controlX, targetX, progress);\r\n    firefly.angle = Math.atan2(dy, dx);\r\n}\r\n\r\nfunction calculateScaledLifespan(loudness) {\r\n    const t = Math.min(Math.max(loudness, 0), 1);\r\n\r\n    if (t < CONFIG.lifespanThreshold) {\r\n        // Scale loudness below threshold linearly to midLifespanSeconds\r\n        const scaled = t / CONFIG.lifespanThreshold;\r\n        return (CONFIG.minLifespanSeconds +\r\n            scaled * (CONFIG.midLifespanSeconds - CONFIG.minLifespanSeconds)) *\r\n            1000 / CONFIG.frameTime; // Convert seconds to frames\r\n    } else {\r\n        // Scale loudness above threshold to maxLifespanSeconds\r\n        const scaled = (t - CONFIG.lifespanThreshold) / (1 - CONFIG.lifespanThreshold);\r\n        return (CONFIG.midLifespanSeconds +\r\n            scaled * (CONFIG.maxLifespanSeconds - CONFIG.midLifespanSeconds)) *\r\n            1000 / CONFIG.frameTime; // Convert seconds to frames\r\n    }\r\n}\r\n\r\nfunction responseCurve(loudness) {\r\n    const midpoint = CONFIG.lifespanThreshold;\r\n    const belowType = CONFIG.responseTypeBelow; // Configurable response type below midpoint\r\n    const aboveType = CONFIG.responseTypeAbove; // Configurable response type above midpoint\r\n\r\n    const computeBelow = (loudness) => {\r\n        switch (belowType) {\r\n            case \"linear\":\r\n                return loudness / midpoint; // Linear scaling\r\n            case \"logarithmic\":\r\n                return Math.log(1 + (loudness / midpoint)) / Math.log(2); // Log base 2 scaling\r\n            case \"quadratic\":\r\n                return Math.pow(loudness / midpoint, 2); // Quadratic scaling\r\n            case \"cubic\":\r\n                return Math.pow(loudness / midpoint, 3); // Cubic scaling\r\n            case \"exponential\":\r\n                return Math.exp(loudness / midpoint) - 1; // Exponential growth\r\n            case \"hyperExponential\":\r\n                return (Math.exp(loudness / midpoint) - 1) * 2; // Doubled exponential effect\r\n            default:\r\n                return loudness; // Default to linear\r\n        }\r\n    };\r\n\r\n    const computeAbove = (relativeLoudness, baseValue) => {\r\n        switch (aboveType) {\r\n            case \"linear\":\r\n                return baseValue + relativeLoudness; // Linear scaling\r\n            case \"logarithmic\":\r\n                return baseValue + Math.log(1 + relativeLoudness) / Math.log(2); // Log base 2 scaling\r\n            case \"quadratic\":\r\n                return baseValue + Math.pow(relativeLoudness, 2); // Quadratic scaling\r\n            case \"cubic\":\r\n                return baseValue + Math.pow(relativeLoudness, 3) * 3; // Cubic scaling\r\n            case \"exponential\":\r\n                return baseValue + (Math.exp(relativeLoudness) - 1); // Exponential scaling\r\n            case \"hyperExponential\":\r\n                return baseValue + (Math.exp(relativeLoudness) - 1) * 2; // Doubled exponential effect\r\n            default:\r\n                return loudness; // Default to linear\r\n        }\r\n    };\r\n\r\n    if (loudness < midpoint) {\r\n        return computeBelow(loudness); // Below midpoint logic\r\n    } else {\r\n        const baseValue = computeBelow(midpoint); // Smooth transition value\r\n        const relativeLoudness = (loudness - midpoint) / (1 - midpoint);\r\n        return computeAbove(relativeLoudness, baseValue); // Above midpoint logic\r\n    }\r\n}\r\n\r\n// Audio setup and initialization\r\ndocument.getElementById('audioUpload').addEventListener('change', async (event) => {\r\n    const file = event.target.files[0];\r\n    if (file) {\r\n        audioContext = new (window.AudioContext || window.webkitAudioContext)();\r\n        const arrayBuffer = await file.arrayBuffer();\r\n        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\r\n\r\n        // Create source and analyzers\r\n        audioSource = audioContext.createBufferSource();\r\n        audioSource.buffer = audioBuffer;\r\n        const splitter = audioContext.createChannelSplitter(2);\r\n\r\n        leftAnalyser = audioContext.createAnalyser();\r\n        rightAnalyser = audioContext.createAnalyser();\r\n\r\n        leftAnalyser.fftSize = 1024;\r\n        rightAnalyser.fftSize = 1024;\r\n\r\n        audioSource.connect(splitter);\r\n        splitter.connect(leftAnalyser, 0);\r\n        splitter.connect(rightAnalyser, 1);\r\n        audioSource.connect(audioContext.destination);\r\n\r\n        leftAnalyser.fftSize = CONFIG.fftSize;\r\n        rightAnalyser.fftSize = CONFIG.fftSize;\r\n\r\n        leftFrequencyData = new Uint8Array(leftAnalyser.frequencyBinCount);\r\n        rightFrequencyData = new Uint8Array(rightAnalyser.frequencyBinCount);\r\n\r\n\t\tfor (let i = 0; i < CONFIG.numFireflies; i++) {\r\n\t\t\tconst frequencyIndex = i % (leftAnalyser.frequencyBinCount / CONFIG.redundancyFactor);\r\n\r\n\t\t\t// Equal split for left and right channels\r\n            const isLeftChannel = i % 2 === 0; // Determine channel\r\n            const frequencySpread = frequencyIndex / (leftAnalyser.frequencyBinCount / CONFIG.redundancyFactor);\r\n            const originX = isLeftChannel\r\n                ? window.innerWidth * (0.5 - frequencySpread * 0.5) // Left: Center to Left\r\n                : window.innerWidth * (0.5 + frequencySpread * 0.5); // Right: Center to Right\r\n\t\t\tconst originY = window.innerHeight / 2; // Middle of the screen\r\n\t\t\t\r\n\t\t\tfireflies.push({\r\n\t\t\t\tfrequencyIndex,\r\n\t\t\t\tchannel: i % 2 === 0 ? 'left' : 'right',\r\n\t\t\t\toriginX,\r\n\t\t\t\toriginY,\r\n\t\t\t\tx: originX,\r\n\t\t\t\ty: originY,\r\n\t\t\t\tsize: CONFIG.fireflySize,\r\n\t\t\t\tglowIntensity: 0,\r\n\t\t\t\tlifeSpan: 0,\r\n\t\t\t\tfixedLoudness: 0,\r\n\t\t\t\tcurveTimer: 0,\r\n\t\t\t\tcurveInterval: 0,\r\n\t\t\t\ttargetX: 0,\r\n\t\t\t\ttargetY: 0,\r\n\t\t\t\tcontrolX: 0,\r\n\t\t\t\tcontrolY: 0,\r\n\t\t\t\tcurveProgress: 0\r\n\t\t\t});\r\n\t\t}\r\n\r\n        console.log(\"Audio loaded and fireflies initialized.\");\r\n        audioSource.start();\r\n        audioSource.onended = () => cancelAnimationFrame(animationFrameId);\r\n\r\n        updateFrequencyData();\r\n    }\r\n});"],"names":["CONFIG","curveIntervalMin","curveIntervalMax","initialDistanceMultiplier","nodeDistanceMin","nodeDistanceMax","controlPointWeightMin","controlPointWeightMax","controlPointOffsetMin","controlPointOffsetMax","movementSpeed","frameTime","fireflySize","numFireflies","redundancyFactor","fftSize","blinkIntervalMin","blinkIntervalMax","loudnessScaleMin","loudnessScaleMax","loudnessThreshold","lifespanThreshold","responseTypeBelow","responseTypeAbove","debugFlightPath","audioContext","audioSource","leftAnalyser","rightAnalyser","animationFrameId","fireflies","leftFrequencyData","rightFrequencyData","canvas","document","getElementById","ctx","getContext","clampPosition","value","min","max","Math","easingFunction","t","calculateControlPoints","originX","originY","targetX","targetY","distance","weightMin","weightMax","offsetMin","offsetMax","weight","random","offsetDistance","deltaX","deltaY","flipDirection","angle","PI","atan2","controlX","baseX","cos","controlY","baseY","sin","width","window","innerWidth","height","innerHeight","addEventListener","event","file","target","files","AudioContext","webkitAudioContext","arrayBuffer","audioBuffer","decodeAudioData","createBufferSource","buffer","splitter","createChannelSplitter","createAnalyser","connect","destination","Uint8Array","frequencyBinCount","i","frequencyIndex","isLeftChannel","frequencySpread","push","channel","x","y","size","glowIntensity","lifeSpan","fixedLoudness","curveTimer","curveInterval","curveProgress","console","log","start","onended","cancelAnimationFrame","updateFrequencyData","getByteFrequencyData","forEach","firefly","frequencyData","blinkTimer","blinkInterval","resetFirefly","scaledLoudness","responseCurve","loudness","midpoint","belowType","aboveType","computeBelow","pow","exp","baseValue","computeAbove","relativeLoudness","pointOriginX","pointOriginY","initialDistance","defaultDistance","baseAngle","blinkProgress","generateTargetPosition","radians","moveAlongBezierCurve","progress","bezier","p0","p1","p2","dx","dy","blinkT","clearRect","index","fireFlySize","blinkOpacity","save","translate","rotate","gradient","createRadialGradient","addColorStop","fillStyle","beginPath","arc","fill","bodyOpacity","ellipse","restore","stroke","flightAngle","relativeAngle","angleToControl","normalizedAngle","dotSize","tipX","tipY","requestAnimationFrame"],"version":3,"file":"firefly.43355cee.js.map"}